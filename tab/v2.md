# Tab Protocol (Tab v2)

Tab v2 uses explicit buffer ownership transfer between compositor clients and Shift.

This file documents the **implemented** v2 behavior.

## Framing

Messages use the same framing as v1:

1. Header line (`ascii`)
2. Payload line (raw string / JSON / `\0\0\0\0`)

FDs are sent with `SCM_RIGHTS` in the same packet.

## Ownership Model

For each `(session_id, monitor_id, buffer_index)` ownership is either:

- `client` (compositor may write/render)
- `shift` (Shift may read/sample/scanout)

Rule: previous owner must not touch the buffer until it is released back.

## Initial State

After `framebuffer_link` (2 dma-buf FDs), both buffers start as client-owned.

## v2 Synchronization Messages

## `buffer_request`

- Direction: `client -> shift`
- Payload: raw string: `<monitor_id> <0|1>`
- FDs: optional `0 or 1`
  - if present, FD is an acquire fence for this buffer request

Meaning:

- client requests transfer of that buffer to Shift
- Shift forwards to rendering layer
- rendering layer validates and reacts

## `buffer_request_ack`

- Direction: `shift -> client`
- Payload: raw string: `<monitor_id> <0|1>`
- FDs: none

Meaning:

- rendering layer accepted request and updated internal state
- ownership transfers to Shift at this point

## `buffer_release`

- Direction: `shift -> client`
- Payload: raw string: `<monitor_id> <0|1>`
- FDs: optional `0 or 1`
  - if present, FD is a release fence produced by Shift

Meaning:

- Shift finished consuming that previously-owned client buffer
- ownership transfers back to client
- if a release fence FD is attached, client must wait it before reusing/writing that buffer

## `error`

- Direction: `shift -> client`
- Payload: JSON `{ code: string, message?: string }`

Used for protocol/ownership violations and renderer rejection.

## `session_awake`

- Direction: `shift -> client`
- Payload: JSON `{ session_id: string }`
- FDs: none

Meaning:

- Shift marked this session as awake.
- Client may resume buffer requests/render cycle immediately.

## `session_sleep`

- Direction: `shift -> client`
- Payload: JSON `{ session_id: string }`
- FDs: none

Meaning:

- Shift marked this session as sleeping.
- Client should stop requesting/presenting new buffers until `session_awake`.

## `session_active`

- Direction: `shift -> client`
- Payload: JSON `{ session_id: string }`
- FDs: none

Meaning:

- Shift changed the globally active (foreground) session.
- Sent to clients so they can update their session state immediately.

## `session_ready`

- Direction: `session client -> shift`
- Payload: JSON `{ session_id: string }`
- FDs: none

Meaning:

- Sent by a non-admin session when shell/session components are fully initialized.
- Before this, session remains in `loading` state.
- Loading sessions may stay awake and render in background, but are not eligible as active session target.

## `session_state`

- Direction: `shift -> admin client`
- Payload: JSON `{ session: SessionInfo }`
- FDs: none

Meaning:

- Shift notifies admin about lifecycle transitions (notably `loading -> occupied`).
- Admin can use this signal to decide when a session is selectable for switching.

## `session_switch`

- Direction: `admin client -> shift`
- Payload: JSON `{ session_id: string, animation?: string | null, duration: number }`
- FDs: none

Meaning:

- Requests foreground switch to `session_id`.
- Target session must be ready (`occupied`) unless it is admin.
- If `animation` is provided and `duration > 0`, Shift runs a live transition.
- During transition, both old and new sessions remain awake and keep producing frames.
- Old session is put to sleep only after animation duration elapses.

## Fence FD Semantics

If `buffer_request` carries an acquire fence FD:

1. ownership still transfers on `buffer_request_ack`
2. rendering layer must not sample/use that slot until the fence is signaled
3. Shift keeps last valid current buffer until pending buffer fence is ready

This avoids reading unfinished compositor writes while avoiding visual stalls.

## Request/Ack/Release Lifecycle

Typical frame flow:

1. Client acquires a free buffer (client-owned) and renders.
2. Client sends `buffer_request <monitor_id> <buffer>` (+ optional fence FD).
3. Shift server records request as pending and forwards to renderer.
4. Renderer:
   - accepts: stores pending slot/fence, emits ack event
   - rejects: emits reject event
5. On accept:
   - Shift sends `buffer_request_ack`
   - ownership becomes `shift`
6. Renderer consumes buffer when fence allows, composes/presents.
7. On later pageflip bookkeeping, Shift sends `buffer_release` for previous front.
8. ownership becomes `client` again.

## Multi-Monitor / Multi-Session Notes

State is tracked per `(session, monitor, buffer)`, so requests/releases are independent per monitor.
During transitions, multiple sessions can have concurrent pending slots/fences.

## Compatibility

v2 is not backward compatible with v1 sync messages.

  - `swap_buffers` / `frame_done` removed
  - `buffer_request` added
  - `buffer_request_ack` added
  - `buffer_release` added
